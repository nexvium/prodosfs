#!/usr/bin/perl
#
# Unknown Word Processor to Text translator.
#
use strict;
use warnings;
use Getopt::Long;

$0 = (split m#/#, $0)[-1];
$| = 1;

my $MAX_FILE_SIZE = (1 << 24) - 1;
my %COLOR = (
    bold_on      => "\e[1m",    bold_off      => "\e[22m",
    faint_on     => "\e[2m",    faint_off     => "\e[22m",
    italic_on    => "\e[3m",    italic_off    => "\e[23m",
    under_on     => "\e[4m",    under_off     => "\e[24m",
    blink_on     => "\e[5m",    blink_off     => "\e[25m",
    inverse_on   => "\e[7m",    inverse_off   => "\e[27m",
    strikeout_on => "\e[9m",    strikeout_off => "\e[29m",
);
my %PLAIN = (
    bold_on      => "",     bold_off      => "",
    faint_on     => "",     faint_off     => "",
    italic_on    => "",     italic_off    => "",
    under_on     => "",     under_off     => "",
    blink_on     => "",     blink_off     => "",
    inverse_on   => "",     inverse_off   => "",
    strikeout_on => "",     strikeout_off => "",
);
my %C = %COLOR;
my $WIDTH = $ENV{COLUMNS} || 120;

if (@ARGV < 1) {
    print STDERR "$0: no file specified\n";
    exit(1);
}
elsif (@ARGV > 1) {
    print STDERR "$0: only one file may be specified\n";
    exit(1);
}

my $CONTENT = undef;

# File is small by modern standards, so just read it all into memory.
open(FILE, '<', $ARGV[0])                       or die "$0: unable to open -- $!\n";
my $n = sysread(FILE, $CONTENT, $MAX_FILE_SIZE) or die "$0: unable to read -- $!\n";
close(FILE)                                     or die "$0: unable to close -- $1\n";

# Files all seem to begin with a 0x126-byte identical header. Only 1 of the 26 files
# differs and only by one byte.
my $header = substr($CONTENT, 0, 0x126, '');
if ($header !~ /^\x80\x19(?:\x01|\x37)\x00\x01\x00\x19\x01\x86\x19\x0a\x01\x14\x14/) {
    print STDERR "$0: does not appear to be an unknown word processor file\n";
    exit(1)
}

# Some variable-length binary data follows which I have no idea what it is, but the start
# of the actual text is preceeded by \x01\x07\x00\x00\x01 or \x01\x08\x00\x00\x01. Since
# the line that follows it looks like a heading, I'm assuming that it's a "center" or
# other justification command.
$CONTENT =~ s/.+(\x01(?:\x07|\x08)\x00\x00\x01)/$1/s;

# All that should be left of the content is the text with \x01...\0x01, which I
# believe are formatting commands.
while (length($CONTENT) > 0) {
    $CONTENT =~ s/^(\x01...\x01)//s;

    my $command = $1;
    my $text_end = index($CONTENT, "\x01") || length($CONTENT);
    my $text = substr($CONTENT, 0, $text_end, '');

    # convert carriage returns and tabs
    $text =~ s/\r/\n\n/g;
    $text =~ s/\t/        /g;

    # these seem to be byte pairs or 16-bit values; no clue what they do
    do { } while ($text =~ s/\x00.//g);

    # again, no idea what these do here
    do { } while ($text =~ s/[\x01-\x06\x0e-\x1f]//g);

    # best guess
    if (not defined($command) or $command eq "\x01\x00\x00\x00\x01") {
        # this appears to be normal text
        print "$text";
    }
    elsif ($command eq "\x01\x00\x00\x01\x01") {
        # this is probably bold, italic, or underlined text
        print "$C{bold_on}$text$C{bold_off}";
    }
    elsif ($command eq "\x01\x00\x00\x02\x01") {
        # this is probably bold, italic, or underlined text
        print "$C{italic_on}$text$C{italic_off}";
    }
    elsif ($command eq "\x01\x00\x00\x04\x01") {
        # this is maybe a list item?
        print "* $C{bold_on}$text$C{bold_off}";
    }
    elsif ($command eq "\x01\x00\x00\x10\x01") {
        # this is probably bold, italic, or underlined text
        print "$C{under_on}$text$C{under_off}";
    }
    elsif ($command eq "\x01\x02\x00\x00\x01") {
        # this is maybe small caps text?
        print "$C{inverse_on}$text$C{inverse_off}";
    }
    elsif ($command eq "\x01\x07\x00\x00\x01" or $command eq "\x01\x08\x00\x00\x01") {
        # this is maybe centered text?
        print " " x (($WIDTH - length $text) / 2);
        print "$text";
    }
    else {
        printf STDERR "$0: unexpected command -- %s\n", unpack("H*", $command);
        exit(1);
    }
}

print "\n";

exit 0;

sub debug_hilite_invisible
{
    # highlight non-printing characters (i.e ASCII 0-31)
    $_[0] =~ s/([\x00-\x1f])/sprintf "$C{inverse_on}\\x%02X$C{inverse_off}",ord($1)/eg;
    return $_[0];
}

# eof
