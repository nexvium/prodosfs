#!/usr/bin/perl
#
# Unknown Word Processor to Text translator.
#
use strict;
use warnings;
use Getopt::Long;

$0 = (split m#/#, $0)[-1];
$| = 1;

my $MAX_FILE_SIZE = (1 << 24) - 1;
my %COLOR = (
    bold_on      => "\e[1m",    bold_off      => "\e[22m",
    faint_on     => "\e[2m",    faint_off     => "\e[22m",
    italic_on    => "\e[3m",    italic_off    => "\e[23m",
    under_on     => "\e[4m",    under_off     => "\e[24m",
    blink_on     => "\e[5m",    blink_off     => "\e[25m",
    inverse_on   => "\e[7m",    inverse_off   => "\e[27m",
    strikeout_on => "\e[9m",    strikeout_off => "\e[29m",
);
my %PLAIN = (
    bold_on      => "",     bold_off      => "",
    faint_on     => "",     faint_off     => "",
    italic_on    => "",     italic_off    => "",
    under_on     => "",     under_off     => "",
    blink_on     => "",     blink_off     => "",
    inverse_on   => "",     inverse_off   => "",
    strikeout_on => "",     strikeout_off => "",
);
my %C = %COLOR;
my $WIDTH = $ENV{COLUMNS} || 120;

if (@ARGV < 1) {
    print STDERR "$0: no file specified\n";
    exit(1);
}
elsif (@ARGV > 1) {
    print STDERR "$0: only one file may be specified\n";
    exit(1);
}

my $CONTENT = undef;

# File is small by modern standards, so just read it all into memory.
open(FILE, '<', $ARGV[0])                       or die "$0: unable to open -- $!\n";
my $n = sysread(FILE, $CONTENT, $MAX_FILE_SIZE) or die "$0: unable to read -- $!\n";
close(FILE)                                     or die "$0: unable to close -- $1\n";

# Files all seem to begin with a 0x127-byte identical header. Only 1 of the 26 files
# differs, and only by one byte.
my $header = substr($CONTENT, 0, 0x127, '');
if ($header !~ /^\x80\x19(?:\x01|\x37)\x00\x01\x00\x19\x01\x86\x19\x0a\x01\x14\x14/) {
    print STDERR "$0: does not appear to be an unknown word processor file\n";
    exit(1)
}

# The text of all the documents begins with a title, which is preceded by a command.
# Assume that command is for selecting the type face and/or size. Leading tabs and
# spaces were used presumably to center the title. Removing them makes centering it
# here easier.
$CONTENT =~ s/^[\x09\x20]+//;

# With all that removed, all that should be left is the actual body of the document.
while (length($CONTENT) > 0) {
    # no idea what the first byte means
    $CONTENT =~ s/^([\x01\x02]...\x01)//s;

    my $command = $1;
    my $text_end = index($CONTENT, "\x01");
    my $text = substr($CONTENT, 0, ($text_end > 0 ? $text_end : length $CONTENT), '');

    # convert carriage returns and tabs
    $text =~ s/\r/\n\n/g;
    $text =~ s/\t/        /g;

    # these seem to be byte pairs or 16-bit values; no clue what they do
    do { } while ($text =~ s/\x00.//g);

    # again, no idea what these do here
    do { } while ($text =~ s/[\x00-\x08\x0e-\x1f]//g);

    # best guess
    if (not defined $command) {
        # treat this as normal text
        print $text;
    }
    elsif ($command =~ /^\x01\x00\x00\x00\x01$/) {
        # this appears to be returning to normal (unstylized) text
        print $text;
    }
    elsif ($command =~ /^\x01[\x00\x03\x06][\x00\x10]([\x01-\x03])\x01$/) {
        # this appears to be a text styling bitmap
        my $style = ord $1;
        if ($style & 0x01) {
            # assume this is bolding
            $text = "$C{bold_on}$text$C{bold_off}";
        }
        if ($style & 0x02) {
            # assume this is italicizing
            $text = "$C{italic_on}$text$C{italic_off}";
        }
        print $text;
    }
    elsif ($command eq "\x01\x00\x00\x04\x01") {
        # this is maybe a list item?
        print "* $C{bold_on}$text$C{bold_off}";
    }
    elsif ($command =~ /^\x01[\x00\x01]\x00\x10\x01$/) {
        # treat this as underlining command
        print "$C{under_on}$text$C{under_off}";
    }
    elsif ($command eq "\x01\x02\x00\x00\x01") {
        # this is maybe small caps text?
        print "$C{inverse_on}$text$C{inverse_off}";
    }
    elsif ($command eq "\x01\x02\x02\x00\x01") {
        # this is maybe changing the type font or size
        $text =~ s/(.)/$1 /g;
        print "$C{blink_on}$text$C{blink_off}";
    }
    elsif ($command =~ /^\x01[\x01\x07\x08]\x00\x00\x01$/) {
        # this always precedes the first line of text
        # assume it's changing the type font or size for the title
        # but just center it here
        print " " x (($WIDTH - length $text) / 2);
        print "$text";
    }
    else {
        no warnings 'once';
        (my $hex = unpack("H*", $command)) =~ s/(..)/\\x$1/g;
        printf STDERR "\n$0: unexpected command -- %s\n", $hex;
        $DB::single=1;
        exit(1);
    }
}

print "\n";

exit 0;

# highlight non-printing characters (i.e ASCII 0-31)
sub hilite_invisible
{
    my $text = substr($_[0], 0, 80);
    $text =~ s/([\x00-\x1f])/sprintf "$C{inverse_on}\\x%02X$C{inverse_off}",ord($1)/eg;
    return $text . (length $_[0] > 80 ? "..." : "");
}

# eof
